<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGnDEV - Three.js Sandbox</title>
    <style>
        html, body {
            margin: 0;
            height: 100%;
        }
        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id = "c"></canvas>    
</body>
<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.137.5';

function main() {
    const canvas = document.querySelector( '#c' );
    const renderer = new THREE.WebGLRenderer( {canvas} );

    const scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x000000 );

    const cameraFov = 40;
    const cameraAspect = 2;
    const cameraNear = 0.1;
    const cameraFar = 1000;
    const camera = new THREE.PerspectiveCamera( cameraFov, cameraAspect, cameraNear, cameraFar );
    camera.position.z = 120;
    camera.position.y = 1;

    const lightColor = 0xFFFFFF;
    const lightIntensity = 1;
    const light = new THREE.DirectionalLight( lightColor, lightIntensity );
    light.position.set( -1, 2, 4 );
    scene.add( light );

    const objects = [];
    const spread = 15;

    function addObject( x, y, obj ) {
        obj.position.x = x * spread;
        obj.position.y = y * spread;

        scene.add( obj );
        objects.push( obj );

        // console.log( "오브젝트 추가 성공 ");

    }

    function createMaterial() {
        const material = new THREE.MeshPhongMaterial( {
            side: THREE.DoubleSide,
        });

        const hue = Math.random();
        const saturation = 1;
        const luminance = 0.5;
        material.color.setHSL( hue, saturation, luminance );
        // console.log( "재질 생성 성공" );
        return material;
    }

    function addSolidGeometry(x, y, geometry) {
    const mesh = new THREE.Mesh(geometry, createMaterial());
    addObject(x, y, mesh);
    }

    function addSolidGeometry( x, y, geometry ) {
        const mesh = new THREE.Mesh( geometry, createMaterial() );
        addObject( x, y, mesh );
        // console.log( "솔리드 지오메트리 추가 성공 ");
    }


    // BoxGeometry
    {
        const width = 10;
        const height = 10;
        const depth = 10;
        addSolidGeometry( -2, -2, new THREE.BoxGeometry( width, height, depth ) );
    }
    
    // BoxGeometry with segsments
    {
        const width = 10;
        const height = 10;
        const depth = 10;
        const widthSegments = 4;
        const heightSegments = 4;
        const depthSegments = 4;
        addSolidGeometry( -1, -2, new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ));
    }

    // Circle with theta
    {
        const radius = 7;
        const segments = 24;
        const thetaStart = Math.PI * 0.25;
        const thetaLength = Math.PI * 1.5;
        addSolidGeometry( 0, -2, new THREE.CircleGeometry( radius, segments, thetaStart, thetaLength ));
    }

    // Cone with theta
    {
        const radius = 6;
        const height = 8;
        const radialSegments = 16;
        const heightSegments = 4;
        const openEnded = true;
        const thetaStart = Math.PI * 0.25;
        const thetaLength = Math.PI * 1.5;
        addSolidGeometry( 1, -2, new THREE.ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ));
    }

    // Cylinder
    {
        const radiusTop = 4;
        const radiusBottom = 4;
        const height = 8;
        const radialSegments = 12;
        addSolidGeometry( 2, -2, new THREE.CylinderGeometry( radiusTop, radiusBottom, height, radialSegments ));
    }

    // Cylinder with theta
    {
        const radiusTop = 4;
        const radiusBottom = 4;
        const height = 8;
        const radialSegments = 12;
        const heightSegments = 2;
        const openEnded = false;
        const thetaStart = Math.PI * 0.25;
        const thetaLength = Math.PI * 1.25;
        addSolidGeometry( -2, -1, new THREE.CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ));
    }

    // DodecahedronGeometry
    {
        const radius = 7;
        addSolidGeometry( -1, -1, new THREE.DodecahedronGeometry( radius ));
    }
    
    // DodecahedronGeometry with detail
    {
        const radius = 7;
        const detail = 2;
        addSolidGeometry( 0, -1, new THREE.DodecahedronGeometry( radius, detail ));
    }

    function resizeRendererToDisplaySize( renderer ) {
        const canvas = renderer.domElement;
        const clientWidth = canvas.clientWidth;
        const clientHeight = canvas.clientHeight;
        const needResize = canvas.width !== clientWidth || canvas.height !== clientHeight;

        if ( needResize ) {
            renderer.setSize( clientWidth, clientHeight, false );
        }
        
        return needResize;
    }   
    
    function render( time ) {
        time *= 0.001;

        if( resizeRendererToDisplaySize( renderer )) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        objects.forEach( (obj, ndx ) => {
            const speed = 0.1 + ndx * 0.05;
            const rot = time * speed;
            obj.rotation.x = rot;
            obj.rotation.y = rot;
        })

        renderer.render( scene, camera );

        requestAnimationFrame( render );
    }

    requestAnimationFrame( render );

}

main();

</script>

</html>

