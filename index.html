<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGnDEV</title>
    <style>
        html, body {
            margin: 0;
            height: 100%;
        }
        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id = "c"></canvas>    
</body>

<script async src="https://unpkg.com/es-module-shims@1.5.5/dist/es-module-shims.js"></script>
<script type="importmap">
    {
        "imports": {
            "three" : "https://unpkg.com/three@0.140.2/build/three.module.js",
            "threeOrbitControls" : "https://unpkg.com/three@0.140.2/examples/jsm/controls/OrbitControls.js",
            "gui" : "https://cdn.jsdelivr.net/npm/lil-gui@0.16/+esm"
        }
    }
</script>
<script type = "module">
import * as THREE from "three";
import { OrbitControls } from "threeOrbitControls";

import GUI from "gui";

function main(){

    const canvas = document.querySelector( '#c' );
    const renderer = new THREE.WebGLRenderer( {canvas} );

    const cameraFov = 40;
    const cameraAspect = 2;
    const cameraNear = 0.1;
    const cameraFar = 100;
    const camera = new THREE.PerspectiveCamera( cameraFov, cameraAspect, cameraNear, cameraFar );
    camera.position.set( 0, 10, 20 );
    

    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x000000 );

    
    const lightColor = 0xFFFFFF;
    const lightIntensity = 1;
    const light = new THREE.DirectionalLight( lightColor, lightIntensity );
    light.position.set( -1, 2, 4 );
    scene.add( light );

    const controls = new OrbitControls( camera, canvas );
    controls.target.set( 0, 5, 0 );
    controls.update();



    const objects = [];

    // const boxWidth = 1;
    // const boxHeight = 1;
    // const boxDepth = 1;
    // const boxGeometry = new THREE.BoxGeometry( boxWidth, boxHeight, boxDepth );
    // const cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xE2AFDE } );N
    // const cubeMesh = new THREE.Mesh( boxGeometry, cubeMaterial );
    // scene.add( cubeMesh );

    const loader = new THREE.TextureLoader();

    const boxWidth = 1;
    const boxHeight = 1;
    const boxGeometry = new THREE.BoxGeometry( boxWidth, boxHeight );
    // const cubeMaterialWithTexture = new THREE.MeshBasicMaterial( {
    //     map: loader.load('resources/images/wall.jpg')
    // });

    const texture = loader.load( 'resources/images/wall.jpg' );
    const cubeMaterial = new THREE.MeshBasicMaterial({
        map: texture,
    });

    const cubeMesh = new THREE.Mesh( boxGeometry, cubeMaterial );
    scene.add( cubeMesh );
    objects.push( cubeMesh );

    const wrapModes = {
    'ClampToEdgeWrapping': THREE.ClampToEdgeWrapping,
    'RepeatWrapping': THREE.RepeatWrapping,
    'MirroredRepeatWrapping': THREE.MirroredRepeatWrapping,
    };
 

    function updateTexture() {
        texture.needsUpdate = true;
    }

    const gui = new GUI();
    gui.add(new StringToNumberHelper(texture, 'wrapS'), 'value', wrapModes)
        .name('texture.wrapS')
        .onChange(updateTexture);
    gui.add(new StringToNumberHelper(texture, 'wrapT'), 'value', wrapModes)
        .name('texture.wrapT')
        .onChange(updateTexture);
    gui.add(texture.repeat, 'x', 0, 5, .01).name('texture.repeat.x');
    gui.add(texture.repeat, 'y', 0, 5, .01).name('texture.repeat.y');
    gui.add(texture.offset, 'x', -2, 2, .01).name('texture.offset.x');
    gui.add(texture.offset, 'y', -2, 2, .01).name('texture.offset.y');
    gui.add(texture.center, 'x', -.5, 1.5, .01).name('texture.center.x');
    gui.add(texture.center, 'y', -.5, 1.5, .01).name('texture.center.y');
    gui.add(new DegRadHelper(texture, 'rotation'), 'value', -360, 360)
        .name('texture.rotation')

    function resizeRendererToDisplaySize( renderer ) {
        const canvas = renderer.domElement;
        const clientWidth = canvas.clientWidth;
        const clientHeight = canvas.clientHeight;
        const needResize = canvas.width !== clientWidth || canvas.height !== clientHeight;

        if ( needResize ) {
            renderer.setSize( clientWidth, clientHeight, false );
        }

        return needResize;
    }

    function render( time ) {
        time *= 0.001;

        objects.forEach( ( obj, ndx ) => {
            const speed = 0.2 + ndx * 0.1;
            const rot = time * speed;
            obj.rotation.x = rot;
            obj.rotation.y = rot;
        });

        if( resizeRendererToDisplaySize( renderer )) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        

        renderer.render( scene, camera );

        requestAnimationFrame( render );
    }

    requestAnimationFrame( render );
}


class DegRadHelper {
    constructor( obj, prop ) {
        this.obj = obj;
        this.prop = prop;
    }

    get value() {
        return THREE.MathUtils.radToDeg( this.obj[this.prop]);
    }
    set value(v) {
        this.obj[this.prop] = THREE.MathUtils.degToRad(v);
    }
}

class StringToNumberHelper {
    constructor( obj, prop ) {
        this.obj = obj;
        this.prop = prop;
    }

    get value() {
        return this.obj[this.prop];
    }
    set value(v) {
        this.obj[this.prop] = parseFloat(v);
    }
}

main();
</script>

</html>