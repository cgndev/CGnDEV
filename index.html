<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGnDEV</title>
    <style>
        html, body {
            margin: 0;
            height: 100%;
        }
        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>

</head>
<body>
    <canvas id="c"></canvas>
</body>
<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.137.5';

function main() {
    const canvas = document.querySelector( '#c' );
    const renderer = new THREE.WebGLRenderer( {canvas} );

    const fov = 45;
    const aspect = 2;
    const near = 0.1;
    const far = 10;
    const camera = new THREE.PerspectiveCamera( fov, aspect, near, far );
    camera.position.z = 5;

    const scene = new THREE.Scene();

    const lightColor = 0xFFFFFF;
    const lightIntensity = 1;
    const light = new THREE.DirectionalLight( lightColor, lightIntensity );
    light.position.set( -1, 2, 4 );
    scene.add(light);


    const boxWidth = 1;
    const boxHeight = 1;
    const boxDepth = 1;
    const boxGeometry = new THREE.BoxGeometry( boxWidth, boxHeight, boxDepth );

    function makeCubeInstance( geometry, color, x ) {
        const cubeMaterial = new THREE.MeshPhongMaterial( { color });
        const cubeMesh = new THREE.Mesh( geometry, cubeMaterial );
        cubeMesh.position.x = x;
        scene.add( cubeMesh );

        return cubeMesh;
    }

    const cubes = [
        makeCubeInstance( boxGeometry, 0xF991CC, 0 ),
        makeCubeInstance( boxGeometry, 0xE2AFDE, -2 ),
        makeCubeInstance( boxGeometry, 0xD3C2CE, 2 )
    ];

    function resizeRendererToDisplaySize( renderer ) {
        const canvas = renderer.domElement;
        const clientWidth = canvas.clientWidth;
        const clientHeight = canvas.clientHeight;
        const needResize = canvas.width !== clientWidth || canvas.height !== cleintHeight;
        
        if ( needResize ) {
            renderer.setSize( clientWidth, clientHeight, false );
        }

        return needResize;
    }

    function render(time) {
        time *= 0.001;

        if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        cubes.forEach( (cube, ndx ) => {
            const speed = 1 + ndx * 0.1;
            const rot = time * speed;
            cube.rotation.x = rot;
            cube.rotation.y = rot;
        });
        
        renderer.render( scene, camera );

        requestAnimationFrame( render );
    }   
    requestAnimationFrame( render );
}

main();

</script>
</html>